# Manejo de archivos y entrada y salida

Ya aprendiste mucho sobre **salida por consola** cuando estudiaste
[cadenas de texto](https://github.com/Fictizia/Master-en-Programacion-con-Python_ed1/blob/master/teoria/b03t01.md#cadenas-de-texto)
y `print` al comienzo del bloque 3.

## Entrada por consola

1. La entrada por consola es tambi칠n muy sencilla. Se utiliza la funci칩n
[`input`](https://docs.python.org/3/library/functions.html#input):

    ```python
    string = input() # will wait for input until pressing enter
    print(f'Entered string is: {string}')
    ```

2. La funci칩n `input` puede imprimir un _prompt_, invitando al usuario a
introducir un texto:

    ```python
    string = input('Enter some text and press enter ')
    print(f'Entered string is: {string}')
    ```

3. El resultado de utilizar `input` es un objeto `str`, **siempre**:

    ```python
    string = input('Enter some text and press enter ')
    type(string)
    ```

4. Es nuestra responsabilidad interpretar la entrada de forma que creamos
oportuna. Por ejemplo:

    ```python
    def parse_coordinates(string):
        x, y = string.split()
        return int(x), int(y)

    user_input = input('Enter a 2D coordinate in the form x y: ')
    coordinates = parse_coordinates(user_input)
    print(coordinates)
    ```

5. Tambi칠n es nuestra reponsabilidad reintentar en caso de error:

    ```python
    def parse_coordinates(string):
        x, y = string.split()
        return int(x), int(y)

    while True:
        user_input = input('Enter a 2D coordinate in the form x y: ')
        try:
            coordinates = parse_coordinates(user_input)
        except:
            print('Invalid syntax!')
        else:
            break

    print(coordinates)
    ```

## Ficheros

El manejo de ficheros en Python est치 en el coraz칩n del lenguaje a trav칠s
de la funci칩n `open`.

**Importante**: en esta secci칩n vas a crear y manipular ficheros, cuando crees
ficheros o los leas utilizando rutas relativas, est치s ser치n **relativas al
directorio de trabajo** que es el lugar desde el que lanzas el int칠rprete. Si
lo haces con PyCharm, el directorio de trabajo ser치 aquel donde est치 el script
que est칠s ejecutando.

1. Crea un nuevo fichero de texto con `open`:

    ```python
    with open('./data.txt', 'w') as f:
        f.write('Greetings, humans!')
    ```

    Comprueba que el fichero existe en el sistema de archivos y que contiene
    exactamente lo que hemos escrito. Recuerda que se habr치 creado en el
    mismo directorio desde el que lanzaste el int칠rprete.

2. Lee ahora el fichero tambi칠n con `open`:

    ```python
    with open('./data.txt', 'r') as f:
        print(f.read())
    ```

    La forma m치s segura y "pit칩nica" de acceder a un fichero es mediante
    un bloque `with`. El contexto (estudiado durante la lecci칩n anterior)
    asegura que, ocurra lo que ocurra durante la ejecuci칩n del cuerpo, el
    fichero se cierra correctamente.

3. El primer par치metro de la funci칩n `open` es la ruta hasta el fichero. El
segundo es el modo de acceso: `'w'` para escribir y `'r'` para leer. Tratar de
leer en un fichero abierto en modo escritura es un error:

    ```python
    with open('./data.txt', 'w') as f:
        f.read()
    ```

    Prueba a escribir en un archivo abierto en modo lectura y comprueba que
    tambi칠n es inv치lido.

4. Abrir un fichero en modo escritura **borra** el contenido anterior. Si
ejecutaste el c칩digo del paso anterior, comprueba en el sistema de ficheros
qu칠 le ha pasado al fichero `data.txt`.

5. Restaura los contenidos del fichero.

6. Si quieres abrir un fichero para **a침adir informaci칩n**, utiliza el modo
`'a'`:

    ```python
    with open('./data.txt', 'a') as f:
        f.write('游띶 I am Ziltoid, the omniscient')
    ```

    Comprueba qu칠 has a침adido la nueva cadena de caracteres al fichero. Si todo
    ha ido bien, la cadena se habr치 a침adido **justo a continuaci칩n** del
    contenido anterior.

7. Puedes abrir un fichero en modo "lectura y escritura":

    ```python
    with open('./data.txt', 'r+') as f:
        text = f.read()
        f.write('\n' + text.upper())
    ```

    En el modo `'r+'`, el fichero no se vac칤a primero.

8. Otra forma de abrir un fichero en modo "lectura y escritura" es:

    ```python
    with open('./data.txt', 'w+') as f:
        text = f.read()
        assert len(text) == 0
    ```

    En el modo `'w+'`, el fichero se trunca al abrirse.

### Modos de apertura

Existen otros modos de abrir un archivo que puedes explorar, combinables
hasta cierto punto:

| Car치cter/Combinaci칩n   | Significado                                        |
|------------------------|----------------------------------------------------|
| `'r'`  | Abiero para lectura (por defecto).                                 |
| `'w'`  | Abierto para escritura, vac칤a el fichero si ya existe.             |
| `'x'`  | Abierto para creaci칩n exclusiva; si ya existe, falla.              |
| `'a'`  | Abierto para escritura, a침ade al final si ya existe.               |
| `'b'`  | Abierto en modo binario, `read` y `write` trabajan con `bytes`.    |
| `'t'`  | Abierto en modo texto (por defecto).                               |
| `'+'`  | Abierto para lectura y escritura.                                  |
| `'r+'` | Abierto para lectura y escritura, a침ade al final si ya existe.     |
| `'w+'` | Abierto para lectura y escritura, vac칤a el fichero si ya existe.   |

### Codificaci칩n

Como puedes comprobar, por defecto `open` trabaja con ficheros de texto. Pero
como ya estudiaste, un fichero de texto s칩lo guarda bytes que representan texto
en alguna codificaci칩n. Podemos indicar la codificaci칩n a utilizar pasando
el par치metro `encoding` a `open`:

```python
with open('./data.txt', 'w+', encoding='utf8') as f:
    text = """Greetings humans!
游띶 I am Ziltoid, the omniscient."""
    f.write(text)
```

Con esto nos aseguramos que el fichero tiene codificaci칩n UTF-8. Si no se
especifica ninguna, la codificaci칩n por defecto se obtiene del sistema,
mediante:

```python
import locale
locale.getpreferredencoding(False)
```

El acceso a ficheros en modo texto es, con diferencia, m치s lento que el acceso
binario del que hablaremos un poco m치s adelante pero ofrece muchas
conveniencias para manejar texto.

### Leyendo l칤nea a l칤nea

En modo texto, podemos leer l칤nea a l칤nea o iterar por las l칤neas de un fichero:

1. Para leer las l칤neas expl칤citamente, utilizamos:

    ```python
    with open('./data.txt', 'r') as f:
        while True:
            line = f.readline()
            if not line:
                break
            print(line)
    ```

2. Para iterar sobre las l칤neas hacemos:

    ```python
    with open('./data.txt', 'r') as f:
        for line in f:
            print(line)
    ```

* Documentaci칩n de los objetos devueltos por `open` en
[modo texto](https://docs.python.org/3/library/io.html#io.TextIOWrapper)

### Trabajo con ficheros binarios

Los ficheros binarios est치n a la orden del d칤as: im치genes, ficheros de audio,
ejecutables, archivos comprimidos...

Cuando se trabaja con ficheros binarios, pasando el modo `'b'`, los m칠todos
de lectura y escritura como `write`, `read` dejan de aceptar cadenas (`str`)
y s칩lo aceptan cadenas de bytes (`bytes`).

Sin embargo, la gesti칩n de tales cadenas de bytes y su significado, queda
totalmente bajo nuestra responsabilidad. Como ejemplo, vamos a crear un formato
que permita crear listas de puntos 2D con coordenadas comprendidas entre
0 y 255.

1. Crea la funci칩n que convierte puntos (tuplas de dos elementos) a bytes
&mdash;el **serializador**&mdash;:

    ```python
    def serialize_point(p):
        if not isinstance(p, tuple) or len(p) != 2:
            raise ValueError('can only serialize tuples of two integers')

        x, y = p
        return serialize_byte(x) + serialize_byte(y)

    def serialize_byte(n):
        if not isinstance(n, int) and (n < 0 or n > 255):
            raise ValueError('can only serialize integers in the range [0, 255]')

        return bytes([n])
    ```

2. Crea la funci칩n que convierte listas de puntos a bytes:

    ```python
    def serialize_point_list(point_list):
        if len(point_list) > 255:
            raise ValueError('cannot serialize lists bigger than 255 elemnts')

        bytes_ = bytearray([len(point_list)])
        for point in point_list:
            bytes_ += serialize_point(point)
        return bytes(bytes_)
    ```

    La representaci칩n es el n칰mero de elemntos (de 0 a 255), seguido de los
    elementos.

3. Ahora podemos escribir estos bytes en un fichero binario:

    ```python
    with open('./test.points', 'wb') as f:
        list_of_points = [(0, 0), (10, 20), (254, 30)]
        f.write(serialize_point_list(list_of_points))
    ```

    Comprueba que el fichero se ha creado correctamente e intenta abrirlo
    con un editor de texto. S칩lo ver치s unos s칤mbolos extra침os, muestra de que
    estamos ante un fichero binario.

Vamos a leerlo.

1. Crea la funci칩n que convierte bytes a puntos (tuplas) &mdash;el
deserializador&mdash;:

    ```python
    def deserialize_point(bytes_):
        if len(bytes_) > 2:
            raise ValueError('point is bad formed')

        x, y = bytes_
        return x, y
    ```

2. Ahora crea el deserializador de listas de puntos:

    ```python
    def deserialize_point_list(bytes_):
        if len(bytes_) < 1:
            raise ValueError('the list of points is bad formed')

        l = bytes_[0]
        points = bytes_[1:]
        if len(points) != l * 2:
            raise ValueError('the list of points is bad formed')

        list_of_points = []
        for i in range(0, len(points), 2):
            point_bytes = points[i:i+2]
            list_of_points.append(deserialize_point(point_bytes))

        return list_of_points
    ```

3. Ahora leemos el archivo en modo binario:

    ```python
    with open('./test.points', 'rb') as f:
        data = f.read()
        list_of_points = deserialize_point_list(data)
        assert list_of_points == [(0, 0), (10, 20), (254, 30)]
    ```

* Documentaci칩n de los objetos devueltos por `open` en
[modo binario](https://docs.python.org/3/library/io.html#io.BufferedIOBase)

#### Relaci칩n entre el modo de texto y el modo binario

Cuando Python abre un fichero en modo texto, realmente lo abre en modo binario
pero le a침ade una capa de codificaci칩n/decodificaci칩n por encima.

Para acceder al objeto binario subyacente, podemos hacer:

```python
with open('./data.txt', 'r') as f:
    character_count = len(f.read())
    underlying_binary_buffer = f.buffer
    underlying_binary_buffer.seek(0) # set the read cursor at the beginning
    byte_count = len(underlying_binary_buffer.read())
    print(f'Char count: {character_count}, Byte count: {byte_count}')
```
쯇or qu칠 hay m치s bytes que caracteres?

### Persistencia de datos

Afortunadamente, serializar y deserializar

### Usar cadenas de texto como ficheros

## Entrada, salida y error est치ndares